name: Automatically sync Infix
on:
  workflow_dispatch:
  schedule:
    - cron: '0 2 * * *'
permissions:
  contents: write
jobs:
  check_changes:
    runs-on: [ self-hosted, latest ]
    if: ${{ vars.SYNC_INFIX }}
    outputs:
      has_changes: ${{ steps.check_changes.outputs.has_changes }}
    steps:
      - uses: actions/checkout@v4
        with:
          token: ${{ secrets.COMMIT_TOKEN }}
          fetch-depth: 0
          submodules: true
      - name: Check for updates and commit if needed
        id: check_changes
        run: |
          git config --global user.name 'Wires bot'
          git config --global user.email 'noreply@wires.se'
          CHANGES=0

          if git ls-remote --heads origin latest | grep -q latest; then
            echo "Latest exists, checking out"
            git checkout latest
            if [[ -n "$(git diff --exit-code origin/main)" ]]; then
              echo "New commits exist on main"
              git merge origin/main
              CHANGES=1
            fi
            git submodule update --init --recursive
          else
            echo "Latest does not exist, create it"
            git checkout -b latest
          fi

          cd infix
          git clean -ffdx
          git checkout main
          git pull origin main
          cd ..

          if [[ -n "$(git diff --exit-code infix)" ]]; then
            git add infix
            git commit infix -m "Step up infix"
            CHANGES=1
          fi

          make defconfigs-generate
          if [[ -n "$(git diff --exit-code configs)" ]]; then
            git add configs
            git commit configs/ -m "Update defconfigs"
            CHANGES=1
          fi

          echo "has_changes=$CHANGES" >> $GITHUB_OUTPUT

      - name: Cache repository state
        if: steps.check_changes.outputs.has_changes == '1'
        run: |
          # Save the current directory state
          tar -czf /tmp/repo-state.tar.gz .

      - uses: actions/cache/save@v3
        if: steps.check_changes.outputs.has_changes == '1'
        with:
          path: /tmp/repo-state.tar.gz
          key: repo-state-${{ github.run_id }}

  push_changes:
    needs: check_changes
    if: needs.check_changes.outputs.has_changes == '1'
    runs-on: [ self-hosted, latest ]
    steps:
      - uses: actions/cache/restore@v3
        with:
          path: /tmp/repo-state.tar.gz
          key: repo-state-${{ github.run_id }}
          fail-on-cache-miss: true

      - name: Restore repository state and push
        run: |
          # Restore the repository state
          rm -rf *
          tar -xzf /tmp/repo-state.tar.gz

          # Configure git and push
          git config --global user.name 'Wires bot'
          git config --global user.email 'noreply@wires.se'
          git push origin latest
